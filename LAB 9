USANDO CONVOLUZIONE
clear all
close all
clc

%%
%RAPPRESENTO IL SEGNALE NEL DOMINIO DEL TEMPO 
N = 5000;
T1 = 100;
T2 = 2;
dt = 2*T1/N; %distanza temporale tra un campione ed un altro

A = 3;

t = [0:N-1]*dt-T1;

s = A*(abs(t) <= T2); %rettangolo

figure;
sgtitle('Filtraggio attraverso convoluzione')

subplot(4,1,1);
plot(t, s, 'LineWidth',1.5)
grid on 
xlabel('Tempo [s]')
ylabel('[V]')
ylim([0 A+0.5])
xlim([-10 10]);
title('Segnale nel tempo')  

%RAPPRESENTO IL FILTRO NEL DOMINIO DELLA FREQUENZA 
Ng = N;
dfg = 1/(Ng*dt); %risoluzione in frequenza, cioè passo tra due campioni consecutivi sull’asse delle frequenze.

fg = [-Ng/2:Ng/2-1]*dfg;
G = 1*(abs(fg) <= 0.5); %rettangolo nel dominio delle frequenze

subplot(4,1,2);
plot(fg, real(G), 'LineWidth',2, 'Color','r','DisplayName','Parte reale');
hold on 
plot(fg, imag(G), 'LineWidth',2, 'Color','#FF00FF','DisplayName','Parte immaginaria');
grid on 
xlabel('Frequenza [Hz]');
ylabel('[Vs]')
title('Risposta in frequenza del filtro')  
xlim([-5 5])
legend;

%CALCOLO ANTITRASFORMATA DEL FILTRO
tg = [-Ng/2:Ng/2-1]*dt; %Asse temporale tg per rappresentare la risposta impulsiva del filtro, lungo Ng campioni.

G = [G(Ng/2+1:end), G(1:Ng/2)]; %G era centrato in frequenza, qui lo ruoti per prepararlo alla ifft (stesso effetto di ifftshift).
g = dfg*Ng*ifft(G); %Calcoli l’antitrasformata di Fourier discreta del filtro.

ifft(G) fa l’antitrasformata discreta.

Moltiplichi per dfg*Ng per normalizzare (così ottieni un’approssimazione della trasformata continua).

Risultato: g è una sinc discretizzata.
g = [g(Ng/2+1:end), g(1:Ng/2)]; %Shift di nuovo per centrare g attorno a 0 (come si fa di solito per la risposta impulsiva).

subplot(4,1,3);
plot(tg, g, 'LineWidth',1.5, 'Color', '#D95319');
xlabel('Tempo [s]');
ylabel('[V]');
grid on 
title('Risposta impulsiva del filtro')  

%CALCOLO CONVOLUZIONE E RAPPRESENTAZIONE
y = dt*conv(s, g);%Esegui la convoluzione numerica tra il tuo segnale s e la risposta impulsiva g.

Il fattore dt serve per approssimare l’integrale continuo della convoluzione.

Risultato: y è il segnale filtrato.

t_y = [0:length(s)+length(g)-2]*dt + t(1)+tg(1); %Crea l’asse temporale per y, tenendo conto che la convoluzione allunga la durata:

La lunghezza di y è length(s) + length(g) - 1.

t(1) e tg(1) servono a riallineare correttamente gli istanti iniziali.

subplot(4,1,4);
plot(t_y, y, 'LineWidth', 1.5, 'Color', 'black');
xlabel('Tempo [s]');
ylabel('[V]');
grid on
title('Segnale filtrato')
xlim([-10 10]);


USO TRASFORMATE
clear all

%RAPPRESENTO IL SEGNALE NEL DOMINIO DEL TEMPO 
N = 5000;
T1 = 100;
T2 = 2;
dt = 2*T1/N;

A = 3;

t = [0:N-1]*dt-T1;

s = A*(abs(t) <= T2);

figure;
sgtitle('Filtraggio attraverso trasformate')

subplot(4,1,1);
plot(t, s, 'LineWidth',1.5)
grid on 
xlabel('Tempo [s]')
ylabel('[V]')
ylim([0 A+0.5])
title('Segnale nel tempo') 
xlim([-10 10])

%CALCOLO LA TRASFORMATA DEL SEGNALE
s = [s(N/2+1:N), s(1:N/2)];
S = dt*fft(s);
S = [S(N/2+1:N), S(1:N/2)];

df = 1/(N*dt);
f = [-N/2:N/2-1]*df;

subplot(4,1,2);
plot(f, real(S), 'LineWidth',1.5, 'Color', 'b', 'DisplayName','Parte reale')
hold on 
plot(f, imag(S), 'LineWidth',1.5, 'Color', '#4DBEEE', 'DisplayName','Parte immaginaria')
grid on 
xlabel('Frequenza [Hz]')
ylabel('[Vs]')
title('Trasformata del segnale');
legend

%RAPPRESENTO IL FILTRO NEL DOMINIO DELLA FREQUENZA 
G = 1*(abs(f) <= 0.5);

subplot(4,1,3);
plot(f, real(G), 'LineWidth',1.5, 'Color', 'red', 'DisplayName','Parte reale');
hold on 
plot(f, imag(G), 'LineWidth',1.5, 'Color', '#FF00FF', 'DisplayName','Parte immaginaria');
grid on 
xlabel('Frequenza [Hz]')
ylabel('[Vs]')
xlim([-5 5])
title('Risposta in frequenza del filtro');
legend

%MOLTIPLICO LE TRASFORMATE
Y = S.*G;
Y = [Y(N/2+1:N), Y(1:N/2)];

%CALCOLO LA TRASFORMATA INVERSA DELL'USCITA E RAPPRESENTAZIONE
y = N*df*ifft(Y);
y = [y(N/2+1:N), y(1:N/2)];

subplot(4,1,4);
plot(t, y, 'LineWidth',1.5, 'Color', 'black')
grid on 
xlabel('Tempo [s]')
ylabel('[V]')
title('Segnale filtrato');
xlim([-10 10]);
